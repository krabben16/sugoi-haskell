# p28

=>というシンボルです。このシンボルよりも前にあるものは型クラス制約と呼ばれます。

# p38

`x:xs` というパターンは、リストの先頭要素をxに束縛し、リストの残りをxsに束縛します。

# p39

複数の変数（そのうち１つが_の場合も）に束縛したいときは丸括弧で囲まなければシンタックスエラーになります。

# p58

関数の型シグネチャ※2は・・・

型を表す文字列のこと

# p65

関数の最初の引数が「１つ引数を取り、同じ型の値を返す関数( `a -> a` )」だということを示しています。

# p72

すでに見たように、２引数の関数に１引数だけ与えたら、１引数を取る関数が返されるのでした。

# p73

ラムダ式とは、１回だけ必要な関数を作るときに使う無名関数です。

# p75

関数を定義するときもうまくラムダ式を使えば、その関数は部分適用され引数として別の関数に渡されるものなのだ、という意図を明確にできます。

# p77

一般に `foo a = bar b a` のような関数があった場合、カリー化のおかげで `foo = bar b` のように書き換えることができます。

# p99

`Maybe a` 型の値は、0個かちょうど1個の要素だけ持てます。

# p113

プロンプトから何らかの値を表示しようとした場合、Haskellはまずその値にshow関数を適用して文字列表記を得て、それを端末に表示します。

# p114

点を定義するとき、データ型と値コンストラクタに同じ名前を使いました。・・・値コンストラクタが１つしかないデータ型はそうするのが慣例です。

# p120

`data Maybe a = Nothing | Just a`

このaが型引数です。そして型引数を取っているので、Maybeは型コンストラクタと呼ばれます。

# p144

新しい型クラスを定義するのがclassで、型を型クラスのインスタンスにするのがinstanceなのです。

# p149

idって何でしょう？これは引数を１つ取って同じものを返すだけの標準ライブラリ関数です。

# p163

右の引数getLineはIO Stringの型を持ちます。文字列とI/Oアクションは連結できません。

# p174

I/Oアクションが特別なのは、main関数の中に入っていると（あるいはGHCiのプロンプトで評価されると）、それが実行されるところです。

# p241

`<*>` は関数の入っているファンクター値と値の入っているファンクター値を引数に取って、１つ目のファンクターの中身である関数を２つ目のファンクターの中身に適用するのです。

# p244

例えば、関数fを３つのアプリカティブ値の引数に適用したければ `f <$> x <*> y <*> z` と書けるのです。

# p263

dataに対するパターンマッチが箱から中身を取り出す操作なのに対し、newtypeに対するパターンマッチは、ある型を別の型へ直接変換する操作なのです。

# p266

１は `*` の単位元であり、[ ]は `++` の単位元です。
